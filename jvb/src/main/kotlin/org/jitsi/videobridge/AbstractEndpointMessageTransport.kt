/*
 * Copyright @ 2017 - Present, 8x8 Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jitsi.videobridge

import org.jitsi.utils.logging2.Logger
import org.jitsi.videobridge.message.BridgeChannelMessage
import org.jitsi.videobridge.message.BridgeChannelMessage.Companion.parse
import org.jitsi.videobridge.message.MessageHandler
import org.jitsi.videobridge.util.TaskPools
import org.json.simple.JSONObject
import java.io.IOException

abstract class AbstractEndpointMessageTransport<T : AbstractEndpoint>(parentLogger: Logger) : MessageHandler() {

    protected val logger: Logger = parentLogger.createChildLogger(javaClass.name)

    abstract val isConnected: Boolean

    /**
     * Fires the message transport ready event for the associated endpoint.
     */
    protected open fun notifyTransportChannelConnected() {}

    /**
     * Notifies this [EndpointMessageTransport] that a specific message
     * has been received on a specific transport channel.
     * @param src the transport channel on which the message has been received.
     * @param msg the message that was received.
     */
    fun onMessage(src: Any, msg: String) {
        val message: BridgeChannelMessage = try {
            parse(msg)
        } catch (ioe: IOException) {
            logger.warn("Invalid message received (" + ioe.message + "): " + msg)
            return
        }
        logger.debug { "RECV: $msg" }
        TaskPools.IO_POOL.submit { handleMessage(message)?.let { response -> sendMessage(src, response) } }
    }

    /**
     * Sends [msg] over the active transport channel of this [EndpointMessageTransport].
     */
    protected open fun sendMessage(msg: BridgeChannelMessage) {}
    protected open fun sendMessage(dst: Any, message: BridgeChannelMessage) =
        logger.debug { "SEND: " + message.toJson() }

    protected open fun close() {}

    open val debugState: JSONObject
        get() = JSONObject().apply {
            this["received_counts"] = JSONObject(getReceivedCounts())
        }

    /**
     * Events generated by [AbstractEndpointMessageTransport] types which are of interest to other entities.
     */
    internal interface EndpointMessageTransportEventHandler {
        fun endpointMessageTransportConnected(endpoint: AbstractEndpoint)
    }
}
