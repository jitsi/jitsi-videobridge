videobridge {
  entity-expiration {
    # If an entity has no activity after this timeout, it is expired
    timeout=1 minute
    # The interval at which the videobridge will check for expired entities
    check-interval=${videobridge.entity-expiration.timeout}
  }
  health {
    # The interval between health checks
    interval=10 seconds
    # The timeout for a health check
    timeout=30 seconds
    # Whether or not health check failures should be 'sticky'
    # (i.e. once the bridge becomes unhealthy, it will never
    # go back to a healthy state)
    sticky-failures=false
  }
  ep-connection-status {
    # How long we'll wait for an endpoint to *start* sending
    # data before we consider it 'inactive'
    first-transfer-timeout=15 seconds
    # How long an endpoint can be 'inactive' before it will
    # be considered disconnected
    max-inactivity-limit=3 seconds
  }
  cc {
    bwe-change-threshold-pct=15
    thumbnail-max-height-px=180
    onstage-preferred-height-px=360
    onstage-preferred-framerate=30
    enable-onstage-video-suspend=false
    trust-bwe=true
    # How often we check to send probing data
    padding-period=15ms
  }
  # The APIs by which the JVB can be controlled
  apis {
    xmpp-client {
      configs {
        # example-connection-id {
        #   For the properties which should be
        #   filled out here, see MucClientConfiguration
        # }
      }
    }
  }
  octo {
    # Whether or not Octo is enabled
    enabled=false
    # A string denoting the 'region' of this JVB.  This region
    # will be used by Jicofo in the selection of a bridge for
    # a client by comparing it to the client's region.
    # Must be set when 'enabled' is true
    #region="us-west-1"
    # The address on which the Octo relay should bind
    # Must be set when 'enabled' is true
    #bind-address=198.51.100.1
    # The port to which the Octo relay should bind
    bind-port=4096
    # The address which controls the public address which
    # will be part of the Octo relayId
    #public-address=198.51.100.1
    # The size of the incoming octo queue. This is a conference level queue and
    # it's where we temporarily store packets from remote bridges.
    #
    # In a 100 participant call and assuming that the bridge has only a single
    # local participant (which is the worst case scenario in terms of load) this
    # queue would have to handle 99*(300pps+200pps+100pps+50pps) = 64350pps. We
    # set its size (in terms of millis) to be 1000ms.
    # With interbridge last-n the load would be much smaller.
    recv-queue-size=64350
  }
  stats {
    enabled=false
    # The default interval at which the stats will run.  This value
    # can be overridden per transport by including an 'interval'
    # value in the transport config object below
    interval=5 seconds
    # Transport configs are objects which must include a 'type'
    # field to denote which type of config they are. Different
    # config types may require additional configuration values.
    # Currently, the supported types are 'colibri', 'muc', 'pubsub'
    # and 'callstatsio'
    transports = [
      # example
      #{
      #  type="colibri"
      #  interval=10 seconds
      #}
    ]
  }
  websockets {
    enabled=true
    server-id="default-id"
    # Optional, even when 'enabled' is set to true
    # tls=true
    # Must be set when enabled = true
    # domain="some-domain"
  }
  ice {
    tcp {
      # Whether ICE/TCP is enabled.
      enabled = false
      # The port to bind to for ICE/TCP.
      port = 443
      # An optional additional port to advertise.
      # mapped-port = 8443
      # Whether to use "ssltcp" or plain "tcp".
      ssltcp = true
    }

    udp {
        # The port for ICE/UDP.
        port = 10000
    }

    # An optional prefix to include in STUN username fragments generated by the bridge.
    # ufrag-prefix = "jvb-123:"

    # Which candidate pairs to keep alive. The accepted values are defined in ice4j's KeepAliveStrategy:
    # "selected_and_tcp", "selected_only", or "all_succeeded".
    keep-alive-strategy = "selected_and_tcp"
    # Whether to use the "component socket" feature of ice4j.
    use-component-socket = true
    # Whether to attempt DNS resolution for remote candidates that contain a non-literal address. When set to 'false'
    # such candidates will be ignored.
    resolve-remote-candidates = false
  }

  transport {
    send {
      # The size of the dtls-transport outgoing queue. This is a per-participant
      # queue. Packets from the egress end-up in this queue right before
      # transmission by the outgoing srtp pipeline (which mainly consists of the
      # packet sender).
      #
      # Its size needs to be of the same order of magnitude as the rtp sender
      # queue. In a 100 participant call, assuming 300pps for the on-stage and
      # 100pps for low-definition, last-n 20 and 2 participants talking, so
      # 2*50pps for audio, this queue is fed 300+19*100+2*50 = 2300pps, so its
      # size in terms of millis is 4096/2300*1000 ~= 1780ms.
      queue-size=4096
    }
  }
}
