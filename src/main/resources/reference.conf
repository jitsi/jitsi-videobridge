videobridge {
  entity-expiration {
    # If an entity has no activity after this timeout, it is expired
    timeout=1 minute
    # The interval at which the videobridge will check for expired entities
    check-interval=${videobridge.entity-expiration.timeout}
  }
  health {
    # The interval between health checks
    interval=10 seconds
    # The timeout for a health check
    timeout=30 seconds
    # If performing a health check takes longer than this, it is considered unsuccessful.
    max-check-duration=3 seconds
    # Whether or not health check failures should be 'sticky'
    # (i.e. once the bridge becomes unhealthy, it will never
    # go back to a healthy state)
    sticky-failures=false
  }
  ep-connection-status {
    # How long we'll wait for an endpoint to *start* sending
    # data before we consider it 'inactive'
    first-transfer-timeout=15 seconds
    # How long an endpoint can be 'inactive' before it will
    # be considered disconnected
    max-inactivity-limit=3 seconds
  }
  cc {
    bwe-change-threshold-pct=15
    thumbnail-max-height-px=180
    onstage-ideal-height-px=1080
    onstage-preferred-height-px=360
    onstage-preferred-framerate=30
    enable-onstage-video-suspend=false
    trust-bwe=true
    # How often we check to send probing data
    padding-period=15ms
  }
  # The APIs by which the JVB can be controlled
  apis {
    xmpp-client {
      configs {
        # example-connection-id {
        #   For the properties which should be
        #   filled out here, see MucClientConfiguration
        # }
      }
    }
    jvb-api {
      enabled = false
      # Which port the API server should listen on
      bind-port = 9099
      # Which address the API server will listen on
      bind-address = 127.0.0.1
      # This field will be used when the JVB advertises its control
      # API address, if it's different than bind-address then it should
      # be set
      public-address = ${videobridge.apis.jvb-api.bind-address}
    }
  }
  octo {
    # Whether or not Octo is enabled
    enabled=false
    # A string denoting the 'region' of this JVB.  This region
    # will be used by Jicofo in the selection of a bridge for
    # a client by comparing it to the client's region.
    # Must be set when 'enabled' is true
    #region="us-west-1"
    # The address on which the Octo relay should bind
    # Must be set when 'enabled' is true
    #bind-address=198.51.100.1
    # The port to which the Octo relay should bind
    bind-port=4096
    # The address which controls the public address which
    # will be part of the Octo relayId
    #public-address=198.51.100.1
    # The size of the incoming octo queue. This queue is per-remote-endpoint,
    # so it matches what we use for local endpoints
    recv-queue-size=1024
    # The size of the outgoing octo queue.  This is a per-originating-endpoint
    # queue, so assuming all packets are routed (as they currently are for Octo)
    # it should be the same size as the transceiver recv queue in
    # jitsi-media-transform.  Repeating the description from there:
    #   Assuming 300pps for high-definition, 200pps for standard-definition,
    #   100pps for low-definition and 50pps for audio, this queue is fed
    #   650pps, so its size in terms of millis is 1024/650*1000 ~= 1575ms.
    send-queue-size=1024
  }
  stats {
    enabled=false
    # The default interval at which the stats will run.  This value
    # can be overridden per transport by including an 'interval'
    # value in the transport config object below
    interval=5 seconds
    # Transport configs are objects which must include a 'type'
    # field to denote which type of config they are. Different
    # config types may require additional configuration values.
    # Currently, the supported types are 'muc' and 'callstatsio'.
    transports = [
      # example
      #{
      #  type="muc"
      #  interval=10 seconds
      #}
    ]
  }
  websockets {
    enabled=true
    server-id="default-id"
    # Optional, even when 'enabled' is set to true
    # tls=true
    # Must be set when enabled = true
    # domain="some-domain"
  }
  ice {
    tcp {
      # Whether ICE/TCP is enabled.
      enabled = false
      # The port to bind to for ICE/TCP.
      port = 443
      # An optional additional port to advertise.
      # mapped-port = 8443
      # Whether to use "ssltcp" or plain "tcp".
      ssltcp = true
    }

    udp {
        # The port for ICE/UDP.
        port = 10000
    }

    # An optional prefix to include in STUN username fragments generated by the bridge.
    # ufrag-prefix = "jvb-123:"

    # Which candidate pairs to keep alive. The accepted values are defined in ice4j's KeepAliveStrategy:
    # "selected_and_tcp", "selected_only", or "all_succeeded".
    keep-alive-strategy = "selected_and_tcp"
    # Whether to use the "component socket" feature of ice4j.
    use-component-socket = true
    # Whether to attempt DNS resolution for remote candidates that contain a non-literal address. When set to 'false'
    # such candidates will be ignored.
    resolve-remote-candidates = false
    # The nomination strategy to use for ICE.  THe accepted values are defined in ice4j's NominationStrategy:
    # "NominateFirstValid", "NominateHighestPriority", "NominateFirstHostOrReflexiveValid", or "NominateBestRTT".
    nomination-strategy = "NominateFirstValid"
  }

  transport {
    send {
      # The size of the dtls-transport outgoing queue. This is a per-participant
      # queue. Packets from the egress end-up in this queue right before
      # transmission by the outgoing srtp pipeline (which mainly consists of the
      # packet sender).
      #
      # Its size needs to be of the same order of magnitude as the rtp sender
      # queue. In a 100 participant call, assuming 300pps for the on-stage and
      # 100pps for low-definition, last-n 20 and 2 participants talking, so
      # 2*50pps for audio, this queue is fed 300+19*100+2*50 = 2300pps, so its
      # size in terms of millis is 1024/2300*1000 ~= 445ms.
      queue-size=1024
    }
  }
}
