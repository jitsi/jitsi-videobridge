package org.jitsi.rtp.rtp.header_extensions

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings
import io.kotest.assertions.throwables.shouldThrow
import io.kotest.core.spec.IsolationMode
import io.kotest.core.spec.style.ShouldSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import jakarta.xml.bind.DatatypeConverter.parseHexBinary

@SuppressFBWarnings(
    value = ["NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE"],
    justification = "Use of pointer after shouldNotBeNull test."
)
class AvtDependencyDescriptorHeaderExtensionTest : ShouldSpec() {
    override fun isolationMode(): IsolationMode = IsolationMode.InstancePerLeaf

    /* Headers generated by Chrome 110 sending AV1 in its default configuration - S1T1 */
    val longDesc1 = parseHexBinary("80000180003a410180ef808680")
    val longDesc2 = parseHexBinary("82007780403a4101813f80b380")
    val longDesc3 = parseHexBinary("8400d380803a410181df810d80")

    val shortDesc1 = parseHexBinary("400001")
    val shortDesc2 = parseHexBinary("870235")
    val shortDesc3 = parseHexBinary("07023a")

    /* Header generated by Chrome 112 sending AV1 with S3T3 set. */
    val longDescScalable = parseHexBinary(
        "d0013481e81485214eafffaaaa863cf0430c10c302afc0aaa0063c00430010c002a000a800060000" +
            "40001d954926e082b04a0941b820ac1282503157f974000ca864330e222222eca8655304224230ec" +
            "a87753013f00b3027f016704ff02cf"
    )

    val midDescScalable = parseHexBinary("d10146401c")

    init {
        context("AVT Dependency Descriptors") {
            context("a descriptor with a single-layer dependency structure") {
                val ld1r = Av1DependencyDescriptorReader(longDesc1, 0, longDesc1.size)
                val ld1 = ld1r.parse(null)
                should("be parsed properly") {
                    ld1.startOfFrame shouldBe true
                    ld1.endOfFrame shouldBe false
                    ld1.frameNumber shouldBe 0x0001

                    val structure = ld1.newTemplateDependencyStructure
                    structure shouldNotBe null
                    structure!!.decodeTargetCount shouldBe 1
                }
                should("be parseable statelessly") {
                    val ld1s = ld1r.parseStateless()
                    ld1s.startOfFrame shouldBe true
                    ld1s.endOfFrame shouldBe false
                    ld1s.frameNumber shouldBe 0x0001

                    val structure = ld1s.newTemplateDependencyStructure
                    structure shouldNotBe null
                    structure!!.decodeTargetCount shouldBe 1
                }
                should("calculate correct frame info") {
                    val ld1i = ld1.frameInfo
                    ld1i.spatialId shouldBe 0
                    ld1i.temporalId shouldBe 0
                }
                should("Calculate its own length properly") {
                    ld1.encodedLength shouldBe longDesc1.size
                }
            }
            context("a descriptor with a scalable dependency structure") {
                val ldsr = Av1DependencyDescriptorReader(longDescScalable, 0, longDescScalable.size)
                val lds = ldsr.parse(null)
                should("be parsed properly") {
                    lds.startOfFrame shouldBe true
                    lds.endOfFrame shouldBe true
                    lds.frameNumber shouldBe 0x0134
                    lds.activeDecodeTargetsBitmask shouldBe 0x1ff

                    val structure = lds.newTemplateDependencyStructure
                    structure shouldNotBe null
                    structure!!.decodeTargetCount shouldBe 9
                }
                should("calculate correct frame info") {
                    val ldsi = lds.frameInfo
                    ldsi.spatialId shouldBe 0
                    ldsi.temporalId shouldBe 0
                }
                should("Calculate its own length properly") {
                    lds.encodedLength shouldBe longDescScalable.size
                }
            }
            context("a descriptor following the dependency structure, specifying decode targets") {
                val ldsr = Av1DependencyDescriptorReader(longDescScalable, 0, longDescScalable.size)
                val lds = ldsr.parse(null)
                val mdsr = Av1DependencyDescriptorReader(midDescScalable, 0, midDescScalable.size)
                val mds = mdsr.parse(lds.newTemplateDependencyStructure)

                should("be parsed properly") {
                    mds.startOfFrame shouldBe true
                    mds.endOfFrame shouldBe true
                    mds.frameNumber shouldBe 0x0146

                    mds.newTemplateDependencyStructure shouldBe null
                    mds.activeDecodeTargetsBitmask shouldBe 0x3
                }
                should("calculate correct frame info") {
                    val mdsi = mds.frameInfo
                    mdsi.spatialId shouldBe 0
                    mdsi.temporalId shouldBe 1
                }
                should("Calculate its own length properly") {
                    mds.encodedLength shouldBe midDescScalable.size
                }
            }
            context("a descriptor without a dependency structure") {
                val mdsr = Av1DependencyDescriptorReader(midDescScalable, 0, midDescScalable.size)
                should("be parseable as the stateless subset") {
                    val mds = mdsr.parseStateless()

                    mds.startOfFrame shouldBe true
                    mds.endOfFrame shouldBe true
                    mds.frameNumber shouldBe 0x0146

                    mds.newTemplateDependencyStructure shouldBe null
                }
                should("fail to parse if the dependency structure is not present") {
                    shouldThrow<Av1DependencyException> {
                        mdsr.parse(null)
                    }
                }
            }
        }
    }
}
